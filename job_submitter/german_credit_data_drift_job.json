{
  "jobType": "MODEL_BATCH_TEST_JOB",
  "jobStatus": "CREATED",
  "inputData": [
    {
      "assetType": "EXTERNAL_FILE",
      "assetRole": "COMPARATOR_DATA",
      "fileUrl": "hdfs:///hadoop/demo/german_credit_model/df_sample_scored.csv",
      "filename": "df_sample_scored.csv",
      "fileFormat": "CSV",
      "repositoryInfo": {
        "repositoryType": "HDFS_REPOSITORY",
        "host": "",
        "port": 0
      }
    },
    {
      "assetType": "EXTERNAL_FILE",
      "assetRole": "TRAINING_DATA",
      "fileUrl": "hdfs:///hadoop/demo/german_credit_model/df_baseline_scored.csv",
      "filename": "df_baseline_scored.csv",
      "fileFormat": "CSV",
      "repositoryInfo": {
        "repositoryType": "HDFS_REPOSITORY",
        "host": "",
        "port": 0
      }
    }
  ],
  "outputData": [
    {
      "assetType": "EXTERNAL_FILE",
      "assetRole": "UNKNOWN",
      "fileUrl": "hdfs:///hadoop/demo/german_credit_model/drift_analysis.json",
      "filename": "drift_analysis.csv",
      "fileFormat": "JSON",
      "repositoryInfo": {
        "repositoryType": "HDFS_REPOSITORY",
        "host": "",
        "port": 0
      }
    }
  ],
  "model": {
    "storedModel": {
      "modelMetaData": {
        "custom": {},
        "tags": [],
        "name": "german_credit_data_drift_detector",
        "type": "PYTHON",
        "inputSchema": [
          {
            "schemaId": "19ab7ac0-42f0-4d09-96b4-38bfa0812410",
            "name": "df_sample_scored_input_schema.avsc",
            "schemaDefinition": [
              {
                "name": "id",
                "type": "int",
                "dataClass": "numerical",
                "role": "non-predictor",
                "protectedClass": false,
                "driftCandidate": false,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "duration_months",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "credit_amount",
                "type": "float",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "installment_rate",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "present_residence_since",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "age_years",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "number_existing_credits",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "checking_status",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "credit_history",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "purpose",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "savings_account",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "present_employment_since",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "debtors_guarantors",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "property",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "installment_plans",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "housing",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "job",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "number_people_liable",
                "type": "int",
                "dataClass": "numerical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "telephone",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "foreign_worker",
                "type": "boolean",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": false
              },
              {
                "name": "gender",
                "type": "string",
                "dataClass": "categorical",
                "role": "predictor",
                "protectedClass": true,
                "driftCandidate": false,
                "specialValues": [],
                "scoringOptional": true
              },
              {
                "name": "label_value",
                "type": "int",
                "dataClass": "numerical",
                "role": "label",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": true
              },
              {
                "name": "score",
                "type": "int",
                "dataClass": "numerical",
                "role": "score",
                "protectedClass": false,
                "driftCandidate": true,
                "specialValues": [],
                "scoringOptional": true
              }
            ]
          }
        ],
        "outputSchema": [],
        "enableInputSchemaChecking": false,
        "enableOutputSchemaChecking": false,
        "attachments": [],
        "repositoryInfo": {
          "classicRepository": false,
          "repositoryType": "GIT_REPO",
          "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
          "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
          "repositoryBranch": "master",
          "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
        }
      },
      "modelAssets": [
        {
          "assetId": "fe1813c3-d2cf-3a40-ae5a-4fbd14901ef8",
          "name": "moc_schema_infer.py",
          "assetType": "SOURCE_CODE",
          "assetRole": "MODEL_SOURCE",
          "repositoryInfo": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "importedRepository": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "primaryModelSource": false,
          "sourceCode": "import pandas as pd\n\n\ndef dtype_map(dtype):\n    \"\"\"\n    Map Python data types to Avro types\n    \n    param: dtype: Python data type\n    return: corresponding Avro type\n    \"\"\"\n\n    if dtype=='int64' or dtype=='int32':\n        return 'int'\n    elif dtype=='float64' or dtype=='float32':\n        return 'float'\n    elif dtype=='O':\n        return 'string'\n    elif dtype=='bool':\n        return 'boolean'\n    else:\n        return None\n\n\ndef dataClass_map(data_type):\n    \"\"\"\n    Map Avro types to dataClass (numerocal vs categorical)\n\n    param: data_type: Avro data type\n    return: numerical vs categorical\n    \"\"\"\n\n    if data_type=='string' or data_type=='boolean':\n        return 'categorical'\n    elif data_type=='float' or data_type=='int':\n        return 'numerical'\n    else:\n        return None\n\n\ndef role_map(field_name):\n    \"\"\"\n    Map DataFrame fields to role\n\n    param: field_name: DF field\n    return: 'label', 'score', 'predictor' or 'non-predictor'\n    \"\"\"\n\n    field_name = field_name.lower()\n\n    if field_name=='label' or field_name=='score':\n        return field_name\n    elif field_name=='id':\n        return 'non-predictor'\n    else:\n        return 'predictor'\n\n\n# Expanded Schema metadata\nmetadata_values = {\n    'type': ['int', 'float', 'string', 'boolean', None],\n    'dataClass': ['numerical', 'categorical', None],\n    'role': ['label', 'score', 'predictor', 'non-predictor'],\n    'protectedClass': [True, False, 0, 1],\n    'driftCandidate': [True, False, 0, 1]\n}\n\n\ndef infer_schema(\n    input_format=None, \n    dataframe=None, \n    filename=None\n    ):\n\n    \"\"\"\n    A function to infer an expanded schema from input df or file\n    \n    param: input_format: 'file' or 'df'\n    param: dataframe: input dataframe\n    param: fielname: input filename\n\n    return: Schema containing metadata for all input data fields\n    \"\"\"\n\n    if input_format=='file':\n        dataframe = pd.read_json(filename, orient='records', lines=True)\n\n    # Schema fields\n    fields=[]\n    dtypes=dict(dataframe.dtypes) # Pandas dtypes\n\n    for field in dataframe.columns.values:\n        # Map Pandas dtypes to AVRO types\n        field_type = dtype_map(dtypes[field])\n\n        fields.append(\n            {\n                'name': field,\n                'type': field_type,\n                'dataClass': dataClass_map(field_type),\n                'role': role_map(field),\n                'protectedClass': False,\n                'driftCandidate': True,\n                'specialValues': []\n            }\n        )\n\n    schema_df = pd.DataFrame(fields)\n    schema_df.set_index('name', inplace=True)\n\n    return schema_df\n\n\ndef validate_schema(dataframe):\n    \n    is_validated = True\n\n    for field in dataframe.index:\n        for metadata in [\n            'type', \n            'dataClass', \n            'role', \n            'protectedClass', \n            'driftCandidate']:\n\n            if dataframe.loc[field, metadata] not in metadata_values[metadata]:\n                print('{} = {} not in {}'.format(\n                    metadata, dataframe.loc[field, metadata], metadata_values[metadata]\n                    )\n                )\n                is_validated = False\n\n    return is_validated\n\n\ndef set_detector_parameters(schema_df):\n    \"\"\"\n    A function to set defaults for detectors\n\n    param: schema_df: expanded schema of input data\n\n    return: map of detectore parameters\n    \"\"\"\n\n    categorical_columns = []\n    numeric_columns = []\n    score_column = []\n    label_column = []\n\n    if validate_schema(schema_df):\n\n        for field in schema_df.index.values:\n\n            if schema_df.loc[field, 'driftCandidate']==True:\n\n                if schema_df.loc[field, 'dataClass']=='categorical':\n                    categorical_columns.append(field)\n                elif schema_df.loc[field, 'dataClass']=='numerical':\n                    numeric_columns.append(field)\n            \n            if schema_df.loc[field, 'role']=='score':\n                score_column.append(field)\n            elif schema_df.loc[field, 'role']=='label':\n                label_column.append(field)\n    else:\n        print('\\nSchema did not pass validation. Setting parameters to defaults.')\n    \n    return {\n        'categorical_columns': categorical_columns, \n        'numerical_columns': numeric_columns, \n        'score_column': score_column, \n        'label_column': label_column\n        }\n",
          "sourceCodeFilePath": "moc_schema_infer.py",
          "sourceCodeType": "MODEL"
        },
        {
          "assetId": "1795a0dd-b822-3a51-8a50-abc33ab0279c",
          "name": "moc_monitors.py",
          "assetType": "SOURCE_CODE",
          "assetRole": "MODEL_SOURCE",
          "repositoryInfo": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "importedRepository": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "primaryModelSource": false,
          "sourceCode": "import pandas as pd\nimport numpy as np\nimport copy\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nfrom scipy.spatial.distance import jensenshannon\nfrom scipy.stats import gaussian_kde, ks_2samp\nfrom sklearn.metrics import (\n    r2_score,\n    mean_absolute_error,\n    precision_score,\n    recall_score,\n    accuracy_score,\n    f1_score,\n    roc_auc_score,\n)\n\nfrom aequitas.preprocessing import preprocess_input_df\nfrom aequitas.group import Group\nfrom aequitas.bias import Bias\n\nimport logging\n\npd.options.mode.chained_assignment = None\n\nlogger = logging.getLogger(__name__)\n\n\nclass DriftDetector:\n    \"\"\"\n    A class to compute differences (by some metric) between two DataFrames:\n    a baseline and a sample.\n\n    Methods\n    -------\n    calculate_drift:\n        Calculates drift between baseline and sample datasets according to\n        a pre-defined metric or a user-defined metric.\n\n    plot_numerical:\n        Plots distribution of numerical features of baseline and sample datasets.\n\n    plot_categorical:\n        Creates a proportion histogram between the 2 datasets for categorical\n        columns.\n\n    Args\n    ----\n    df_baseline: <pandas.DataFrame>\n        Pandas DataFrame of the baseline dataset. \n\n    df_sample: <pandas.DataFrame>\n        Pandas DataFrame of the sample dataset.\n\n    categorical_columns: <list of str>\n        A list of categorical columns in the dataset. If not provided, categorical \n        columns will be inferred from column types.\n\n    numerical_columns: <list of str>\n        A list of numerical columns in the dataset. If not provided, numerical \n        columns will be inferred from column types.\n\n    score_column: <str>\n        Column containing predicted values (as computed by underlying model).\n\n    label_column: <str>\n        Column containing actual values (ground truths).\n\n    # label_type: <str>\n    #     'categorical' or 'numerical' to reflect classification or regression.\n    \"\"\"\n\n    def __init__(\n        self,\n        df_baseline,\n        df_sample,\n        categorical_columns=None,\n        numerical_columns=None,\n        score_column=None,\n        label_column=None,\n        # label_type=None,\n    ):\n        assert isinstance(\n            df_baseline, pd.DataFrame\n        ), \"df_baseline should be of type <pandas.DataFrame>.\"\n\n        assert isinstance(\n            df_sample, pd.DataFrame\n        ), \"df_baseline should be of type <pandas.DataFrame>.\"\n\n        assert all(\n            df_baseline.columns == df_sample.columns\n        ), \"df_baseline and df_sample should have the same column names.\"\n\n        assert all(\n            df_baseline.dtypes == df_sample.dtypes\n        ), \"df_baseline and df_sample should have the same column types.\"\n\n        assert isinstance(\n            categorical_columns, (list, type(None))\n        ), \"categorical_columns should be of type <list>.\"\n\n        assert isinstance(\n            numerical_columns, (list, type(None))\n        ), \"numerical_columns should be of type <list>.\"\n\n        assert isinstance(\n            score_column, (str, type(None))\n        ), \"score_column should be of type <str>.\"\n\n        assert isinstance(\n            label_column, (str, type(None))\n        ), \"label_column should be of type <str>.\"\n\n        if score_column:\n            assert (\n                score_column in df_baseline.columns\n            ), \"score_column does not exist in df_baseline.\"\n\n        if label_column:\n            assert (\n                label_column in df_baseline.columns\n            ), \"label_column does not exist in df_baseline.\"\n\n        #if label_type:\n        #    assert isinstance(label_type, str), \"label_type should be of type <str>\"\n        #    assert label_type in (\n        #        \"categorical\",\n        #        \"numerical\",\n        #    ), \"label_type should be either 'categroical' or 'numerical'.\"\n\n        df_baseline_ = copy.deepcopy(df_baseline)\n        df_sample_ = copy.deepcopy(df_sample)\n\n        # infer categorical columns if not specified\n        if categorical_columns is None:\n            categorical_columns = [\n                c\n                for c in df_baseline_.columns\n                if (\n                    (df_baseline_.dtypes[c] == \"object\")\n                    and (c != score_column)\n                    and (c != label_column)\n                )\n            ]\n            logger.info(\"Identified categorical column(s): \", categorical_columns)\n\n        # cast categorical values as strings\n        df_baseline_[categorical_columns] = df_baseline_[categorical_columns].astype(\n            str\n        )\n        df_sample_[categorical_columns] = df_sample_[categorical_columns].astype(str)\n\n        # infer numerical columns if not specified\n        if numerical_columns is None:\n            num_types = [\"float64\", \"float32\", \"int32\", \"int64\", \"uint8\"]\n            numerical_columns = [\n                c\n                for c in df_baseline_.columns\n                if (\n                    (df_baseline_.dtypes[c] in num_types)\n                    and (c != score_column)\n                    and (c != label_column)\n                )\n            ]\n            logger.info(\"Identified numerical column(s): \", numerical_columns)\n\n        # cast numerical values as floats\n        df_baseline_[numerical_columns] = df_baseline_[numerical_columns].astype(float)\n        df_sample_[numerical_columns] = df_sample_[numerical_columns].astype(float)\n\n        # Set attributes\n        self.categorical_columns = categorical_columns\n        self.numerical_columns = numerical_columns\n\n        self.score_column = score_column\n        self.label_column = label_column\n\n        # self.label_type = label_type\n\n        self.df_baseline = df_baseline_\n        self.df_sample = df_sample_\n\n\n    def calculate_drift(\n        self, \n        pre_defined_metric=None,\n        user_defined_metric=None\n        ):\n\n        \"\"\"\n        Calculates drift between baseline and sample datasets according to\n        a pre-defined metric (jensen-shannon distance or KS) or a user-defined metric.\n\n        param: pre_defined_metric: \"jensen-shannon\" or \"ks\".\n        param: user_defined_metric: function defined by user to compute drift.\n\n        return: drift measures as computed by some metric function.\n        \"\"\"\n\n        if pre_defined_metric and user_defined_metric:\n            print(\"One of pre_defined_metric or user_defined_metric must be None.\")\n\n        elif pre_defined_metric:\n            # Remove capitalization\n            pre_defined_metric = pre_defined_metric.lower()\n\n            assert pre_defined_metric in (\n                \"jensen-shannon\",\n                \"ks\",\n            ), \"pre_defined_metric should be either 'jensen-shannon' or 'ks'.\"\n\n            if pre_defined_metric == \"jensen-shannon\":\n                return js_metric(\n                    df_1=self.df_baseline,\n                    df_2=self.df_sample,\n                    numerical_columns=self.numerical_columns,\n                    categorical_columns=self.categorical_columns\n                )\n\n            elif pre_defined_metric == \"ks\":\n                return ks_metric(\n                    df_1=self.df_baseline, \n                    df_2=self.df_sample, \n                    numerical_columns=self.numerical_columns\n                )\n        \n        # No pre_defined_metric specified - check if use_defined_metric is provided\n        elif user_defined_metric:\n            return user_defined_metric\n        \n        # Raise error\n        else:\n            print(\"A metric (user_defined or pre_defined) must be provided.\")\n\n\n    def plot_numerical(self, plot_numerical_columns=None, alpha=0.5):\n        \"\"\"\n        Plots distribution of numerical features of baseline and sample datasets\n\n        Args\n        ----\n        plot_numerical_columns: <list of str>\n            List of numerical columns to plot, uses all if not specified\n\n        alpha: <float>\n            Transparency of the scatter plot\n\n        Returns\n        ----\n        Resulting plot\n        \"\"\"\n        assert isinstance(\n            plot_numerical_columns, (list, type(None))\n        ), \"plot_numerical_columns should be of type list\"\n\n        if plot_numerical_columns is None:\n            plot_numerical_columns = self.numerical_columns\n\n        df_baseline = self.df_baseline[plot_numerical_columns].copy()\n        df_sample = self.df_sample[plot_numerical_columns].copy()\n\n        df_baseline[\"source\"] = \"baseline\"\n        df_sample[\"source\"] = \"sample\"\n\n        plot_df = pd.concat([df_baseline, df_sample])\n\n        logger.info(\"Plotting the following numerical column(s):\", plot_numerical_columns)\n\n        num_numerical_features = len(plot_numerical_columns)\n        column_wrap = 4\n        ncols = min(num_numerical_features, column_wrap)\n        nrows = 1 + (num_numerical_features - 1) // column_wrap\n\n        fig, axes = plt.subplots(\n            ncols=ncols,\n            nrows=nrows,\n            sharex=False,\n            sharey=False,\n            figsize=(5 * ncols, 3 * nrows),\n            squeeze=False,\n        )\n\n        indices = []\n        for i in range(nrows):\n            for j in range(ncols):\n                indices.append((i, j))\n\n        for i in range(len(indices) - num_numerical_features):\n            axes.flat[-1 - i].set_visible(False)  # to remove plot\n\n        cnt = 0\n        for feature in plot_numerical_columns:\n\n            sns.kdeplot(\n                ax=axes[indices[cnt]],\n                data=plot_df,\n                x=feature,\n                hue=\"source\",\n                fill=True,\n                alpha=alpha,\n                common_norm=False,\n            )\n            cnt += 1\n\n        # plt.legend()\n        plt.close(fig)\n\n        return fig\n\n\n    def plot_categorical(self, plot_categorical_columns=None):\n        \"\"\"Plot histograms to compare categorical columns\n\n        Args\n        ----\n        plot_categorical_columns: <list of str>\n            List of categorical columns to plot, uses all if no specified\n\n        Returns\n        ----\n        Resulting plot\n\n        \"\"\"\n        assert isinstance(\n            plot_categorical_columns, (list, type(None))\n        ), \"plot_categorical_columns should be of type list\"\n\n        # Count distinct values in each column\n        col_nunique = self.df_baseline.nunique()\n\n        # won't plot categoricals with more than 20 values\n        if plot_categorical_columns is None:\n            plot_categorical_columns = [\n                col\n                for col in col_nunique.index\n                if ((col_nunique[col] <= 20) & (col in self.categorical_columns))\n            ]\n\n        logger.info(\n            \"Plotting the following categorical column(s):\", plot_categorical_columns\n        )\n\n        fig, ax = plt.subplots(\n            len(plot_categorical_columns),\n            2,\n            figsize=(10, 5 * len(plot_categorical_columns)),\n        )\n\n        for i, col in enumerate(plot_categorical_columns):\n\n            if len(plot_categorical_columns) == 1:\n                _ax0 = ax[0]\n                _ax1 = ax[1]\n            elif len(plot_categorical_columns) > 1:\n                _ax0 = ax[i, 0]\n                _ax1 = ax[i, 1]\n\n            # Get all values and counts from baseline and sample dfs\n            df_baseline_values = (\n                self.df_baseline[col]\n                .value_counts(normalize=True, dropna=False)\n                .index.values\n            )\n            df_sample_values = (\n                self.df_sample[col]\n                .value_counts(normalize=True, dropna=False)\n                .index.values\n            )\n\n            # Get all unique values in the union of both lists above\n            all_values = np.union1d(df_baseline_values, df_sample_values)\n\n            # recount values in each df to include missing values in each - impute by zero\n            df_baseline_values = (\n                self.df_baseline[col].value_counts()[all_values].fillna(0)\n            )\n            df_sample_values = self.df_sample[col].value_counts()[all_values].fillna(0)\n\n            # generate side-by-side barplots\n            (\n                df_baseline_values.rename(\"Proportion\")\n                .sort_index()\n                .reset_index()\n                .pipe((sns.barplot, \"data\"), x=\"index\", y=\"Proportion\", ax=_ax0)\n            )\n            _ax0.set_title(col + \", baseline\")\n            _ax0.set(xlabel=col)\n            (\n                df_sample_values.rename(\"Proportion\")\n                .sort_index()\n                .reset_index()\n                .pipe((sns.barplot, \"data\"), x=\"index\", y=\"Proportion\", ax=_ax1)\n            )\n            _ax1.set(xlabel=col)\n            _ax1.set_title(col + \", sample\")\n\n        plt.close(fig)\n\n        return fig\n\n\nclass ModelEvaluator:\n    \"\"\"\n    A class to evaluate the performance of a ML model on baseline and sample datasets.\n\n    Methods\n    -------\n    compare_performance:\n        Compares model performance on baseline and sample datasets.\n\n    Args\n    ----\n    df_baseline: <pandas.DataFrame>\n        Pandas DataFrame of the baseline dataset. \n\n    df_sample: <pandas.DataFrame>\n        Pandas DataFrame of the sample dataset.\n\n    score_column: <str>\n        Column containing predicted values (as computed by underlying model).\n\n    label_column: <str>\n        Column containing actual values (ground truths).\n\n    label_type: <str>\n        'categorical' or 'numerical' to reflect classification or regression.\n    \"\"\"\n\n    def __init__(\n        self,\n        df_baseline,\n        df_sample,\n        score_column,\n        label_column,\n        label_type=None):\n        \n        assert isinstance(\n            df_baseline, pd.DataFrame\n        ), \"df_baseline should be of type <pandas.DataFrame>.\"\n\n        assert isinstance(\n            df_sample, pd.DataFrame\n        ), \"df_baseline should be of type <pandas.DataFrame>.\"\n\n        assert all(\n            df_baseline.columns == df_sample.columns\n        ), \"df_baseline and df_sample should have the same column names.\"\n\n        assert all(\n            df_baseline.dtypes == df_sample.dtypes\n        ), \"df_baseline and df_sample should have the same column types.\"\n\n        assert isinstance(\n            score_column, str\n        ), \"score_column should be of type <str>.\"\n\n        assert isinstance(\n            label_column, str\n        ), \"label_column should be of type <str>.\"\n\n        assert (\n            score_column in df_baseline.columns\n        ), \"score_column does not exist in df_baseline.\"\n\n        assert (\n            label_column in df_baseline.columns\n        ), \"label_column does not exist in df_baseline.\"\n\n        if label_type:\n            assert isinstance(label_type, str), \"label_type should be of type <str>\"\n            assert label_type in (\n                \"categorical\",\n                \"numerical\",\n            ), \"label_type should be either \\\n                'categroical' (classification) or 'numerical' (regression).\"\n        \n        self.df_baseline = df_baseline\n        self.df_sample = df_sample\n        self.score_column = score_column\n        self.label_column = label_column\n        self.label_type = label_type\n\n\n    def _rmse(targets, predictions):\n        return np.sqrt(np.mean((predictions - targets) ** 2))\n\n\n    def compare_performance(self):\n        \"\"\"\n        A method to compare model performance on baseline and sample datasets.\n        Will call _eval_classifier or _eval_regressor depending on label_type.\n\n        param: score_column <str>: column containing predicted values.\n        param: label_column <str>: column containing actual values.\n\n        return: a DataFrame of ML metrics computed on baseline and sample datasets.\n        \"\"\"\n\n        if self.label_type == \"categorical\":\n            self._eval_classifier()\n\n        elif self.label_type == \"numerical\":\n            self._eval_regressor()\n\n        return self.performance_comparison\n\n\n    def _eval_regressor(self):\n        \"\"\"\n        A funtion to compute RMSE, MAE, and R2 score on baseline and sample datasets.\n\n        return: a Pandas DataFrame of the results indexed by data source.\n        \"\"\"\n\n        y_pred_baseline = self.df_baseline[self.score_column]\n        y_pred_sample = self.df_sample[self.score_column]\n\n        y_label_baseline = self.df_baseline[self.label_column]\n        y_label_sample = self.df_sample[self.label_column]\n\n        rmse_baseline = self._rmse(y_label_baseline, y_pred_baseline)\n        mae_baseline = mean_absolute_error(y_label_baseline, y_pred_baseline)\n        r2_baseline = r2_score(y_label_baseline, y_pred_baseline)\n\n        rmse_sample = self._rmse(y_label_sample, y_pred_sample)\n        mae_sample = mean_absolute_error(y_label_sample, y_pred_sample)\n        r2_sample = r2_score(y_label_sample, y_pred_sample)\n\n        metrics_df = pd.DataFrame(\n            {\n                \"RMSE\": [rmse_baseline, rmse_sample],\n                \"MAE\": [mae_baseline, mae_sample],\n                \"R2\": [r2_baseline, r2_sample],\n            },\n            index=[\"baseline\", \"sample\"],\n        )\n\n        self.performance_comparison = metrics_df\n\n\n    def _eval_classifier(self):\n        \"\"\"\n        A function to compute accuracy, precision, recall, F1 score, and AUC on\n        baseline and sample datasets.\n\n        return: a Pandas DataFrame of the results indexed by data source.\n        \"\"\"\n\n        y_pred_baseline = self.df_baseline[self.score_column]\n        y_pred_sample = self.df_sample[self.score_column]\n\n        y_label_baseline = self.df_baseline[self.label_column]\n        y_label_sample = self.df_sample[self.label_column]\n\n        precision_baseline = precision_score(y_label_baseline, y_pred_baseline)\n        recall_baseline = recall_score(y_label_baseline, y_pred_baseline)\n        acc_baseline = accuracy_score(y_label_baseline, y_pred_baseline)\n        f1_baseline = f1_score(y_label_baseline, y_pred_baseline)\n        try:\n            auc_baseline = roc_auc_score(y_label_baseline, y_pred_baseline)\n        except ValueError:\n            auc_baseline = \"NA\"\n\n        precision_sample = precision_score(y_label_sample, y_pred_sample)\n        recall_sample = recall_score(y_label_sample, y_pred_sample)\n        acc_sample = accuracy_score(y_label_sample, y_pred_sample)\n        f1_sample = f1_score(y_label_sample, y_pred_sample)\n        try:\n            auc_sample = roc_auc_score(y_label_sample, y_pred_sample)\n        except ValueError:\n            auc_sample = \"NA\"\n\n        metrics_df = pd.DataFrame(\n            {\n                \"Accuracy\": [acc_baseline, acc_sample],\n                \"Precision\": [precision_baseline, precision_sample],\n                \"Recall\": [recall_baseline, recall_sample],\n                \"F1\": [f1_baseline, f1_sample],\n                \"AUC\": [auc_baseline, auc_sample],\n            },\n            index=[\"baseline\", \"sample\"],\n        )\n\n        self.performance_comparison = metrics_df\n\n\nclass BiasMonitor:\n    \n    def __init__(\n        self,\n        df=None,\n        score_column=None,\n        label_column=None,\n        protected_class=None,\n        reference_group=None,\n    ):\n\n        self.df = df\n        self.score_column = score_column\n        self.label_column = label_column\n        self.protected_class = protected_class\n        self.reference_group = reference_group\n\n    def compute_group_metrics(\n        self, \n        pre_defined_metric=None, \n        user_defined_metric=None\n        ):\n\n        if pre_defined_metric:\n            assert pre_defined_metric in (\n                \"aequitas_group\"\n            ), \"pre_defined_metric should be one of ['aequitas_group']\"\n\n            if pre_defined_metric == \"aequitas_group\":\n                return aequitas_group(\n                    self.df,\n                    self.score_column,\n                    self.label_column,\n                    self.protected_class\n                )\n        elif user_defined_metric:\n            return user_defined_metric\n        \n        # Raise error\n        else:\n            print(\"A metric (user_defined or pre_defined) must be provided \")\n\n    def compute_bias_metrics(\n        self, \n        pre_defined_metric=None, \n        user_defined_metric=None\n        ):\n\n        if pre_defined_metric:\n            assert pre_defined_metric in (\n                \"aequitas_bias\"\n            ), \"pre_defined_metric should be one of ['aequitas_bias']\"\n\n            if pre_defined_metric == \"aequitas_bias\":\n                return aequitas_bias(\n                    self.df,\n                    self.score_column,\n                    self.label_column,\n                    self.protected_class,\n                    self.reference_group\n                )\n        elif user_defined_metric:\n            return user_defined_metric\n        \n        # Raise error\n        else:\n            print(\"A metric (user_defined or pre_defined) must be provided \")\n\n\n\n\n\ndef ks_metric(df_1, df_2, numerical_columns):\n    ks_tests = [\n        ks_2samp(\n            data1=df_1.loc[:, feat],\n            data2=df_2.loc[:, feat],\n        )\n        for feat in numerical_columns\n    ]\n    pvalues = [x[1] for x in ks_tests]\n    list_of_pval = [f\"{feat}_p-value\" for feat in numerical_columns]\n\n    ks_pvalues = dict(zip(list_of_pval, pvalues))\n\n    return ks_pvalues\n\n\ndef js_metric(df_1, df_2, numerical_columns, categorical_columns):\n    \"\"\"\n    A function to compute the jensen-shannon distances between columns of\n    similar DataFrames.\n\n    For categorical columns, the probability of each category will be\n    computed separately for `df_baseline` and `df_sample`, and the Jensen\n    Shannon distance between the 2 probability arrays will be computed. \n    \n    For numerical columns, the values will first be fitted into a gaussian KDE\n    separately for `df_baseline` and `df_sample`, and a probability array\n    will be sampled from them and compared with the Jensen Shannon distance.\n\n    param: df_1: baseline DataFrame\n    param: df_2: sample DataFrame\n    param: numerical_columns: list of numerical columns\n    param: categorical_columns: list of categorical columns\n\n    return: sorted list of tuples containing the column names and Jensen-Shannon \n    distances.\n    \"\"\"\n\n    res = {}\n    STEPS = 100\n\n    for col in categorical_columns:\n        # to ensure similar order, concat before computing probability\n        col_baseline = df_1[col].to_frame()\n        col_sample = df_2[col].to_frame()\n        col_baseline[\"source\"] = \"baseline\"\n        col_sample[\"source\"] = \"sample\"\n\n        col_ = pd.concat([col_baseline, col_sample], ignore_index=True)\n\n        # aggregate and convert to probability array\n        arr = (\n            col_.groupby([col, \"source\"])\n            .size()\n            .to_frame()\n            .reset_index()\n            .pivot(index=col, columns=\"source\")\n            .droplevel(0, axis=1)\n        )\n        arr_ = arr.div(arr.sum(axis=0), axis=1)\n        arr_.fillna(0, inplace=True)\n\n        # calculate js distance\n        js_distance = jensenshannon(\n            arr_[\"baseline\"].to_numpy(), arr_[\"sample\"].to_numpy()\n        )\n\n        res.update({col: js_distance})\n\n    for col in numerical_columns:\n        # fit gaussian_kde\n        col_baseline = df_1[col]\n        col_sample = df_2[col]\n        kde_baseline = gaussian_kde(col_baseline)\n        kde_sample = gaussian_kde(col_sample)\n\n        # get range of values\n        min_ = min(col_baseline.min(), col_sample.min())\n        max_ = max(col_baseline.max(), col_sample.max())\n        range_ = np.linspace(start=min_, stop=max_, num=STEPS)\n\n        # sample range from KDE\n        arr_baseline_ = kde_baseline(range_)\n        arr_sample_ = kde_sample(range_)\n\n        arr_baseline = arr_baseline_ / np.sum(arr_baseline_)\n        arr_sample = arr_sample_ / np.sum(arr_sample_)\n\n        # calculate js distance\n        js_distance = jensenshannon(arr_baseline, arr_sample)\n\n        res.update({col: js_distance})\n\n    list_output = sorted(res.items(), key=lambda x: x[1], reverse=True)\n    dict_output = dict(list_output)\n\n    return dict_output\n\n\ndef aequitas_group(df, score_column, label_column, protected_class):\n    # To measure Bias towards protected_class, filter DataFrame\n    # to score, label (ground truth), and protected class\n    data_scored = df[\n        [\n            score_column,\n            label_column,\n            protected_class,\n        ]\n    ]\n\n    # Aequitas expects ground truth under 'label_value'\n    data_scored = data_scored.rename(columns={label_column: \"label_value\"})\n\n    # Process DataFrame\n    data_scored_processed, _ = preprocess_input_df(data_scored)\n\n    # Group Metrics\n    g = Group()\n    xtab, _ = g.get_crosstabs(data_scored_processed)\n\n    # Absolute metrics, such as 'tpr', 'tnr','precision', etc.\n    absolute_metrics = g.list_absolute_metrics(xtab)\n\n    # DataFrame of calculated absolute metrics for each sample population group\n    absolute_metrics_df = xtab[\n        [\"attribute_name\", \"attribute_value\"] + absolute_metrics\n    ].round(2)\n\n    # For example:\n    \"\"\"\n        attribute_name  attribute_value     tpr     tnr  ... precision\n    0   gender          female              0.60    0.88 ... 0.75\n    1   gender          male                0.49    0.90 ... 0.64\n    \"\"\"\n\n    return absolute_metrics_df\n\n\ndef aequitas_bias(df, score_column, label_column, protected_class, reference_group):\n    \n    # To measure Bias towards protected_class, filter DataFrame\n    # to score, label (ground truth), and protected class\n    data_scored = df[\n        [\n            score_column,\n            label_column,\n            protected_class,\n        ]\n    ]\n\n    data_scored = data_scored.rename(columns={label_column: \"label_value\"})\n\n    # Process DataFrame\n    data_scored_processed, _ = preprocess_input_df(data_scored)\n\n    # Bias Metrics\n    b = Bias()\n    g = Group()\n    xtab, _ = g.get_crosstabs(data_scored_processed)\n\n    # Disparities calculated in relation <protected_class> for class groups\n    bias_df = b.get_disparity_predefined_groups(\n        xtab,\n        original_df=data_scored_processed,\n        ref_groups_dict={protected_class: reference_group},\n        alpha=0.05,\n        mask_significance=True,\n    )\n\n    # Disparity metrics added to bias DataFrame\n    calculated_disparities = b.list_disparities(bias_df)\n\n    disparity_metrics_df = bias_df[\n        [\"attribute_name\", \"attribute_value\"] + calculated_disparities\n    ]\n\n    # For example:\n    \"\"\"\n        attribute_name\tattribute_value    ppr_disparity   precision_disparity\n    0   gender          female             0.714286        1.41791\n    1   gender          male               1.000000        1.000000\n    \"\"\"\n\n    return disparity_metrics_df\n",
          "sourceCodeFilePath": "moc_monitors.py",
          "sourceCodeType": "MODEL"
        },
        {
          "assetId": "dd912662-42b3-3746-9c7e-1bf3ed8641b5",
          "name": "monitor.py",
          "assetType": "SOURCE_CODE",
          "assetRole": "MODEL_SOURCE",
          "repositoryInfo": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "importedRepository": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "primaryModelSource": true,
          "sourceCode": "UPDATE_ME",
          "sourceCodeFilePath": "monitor.py",
          "sourceCodeType": "MODEL",
          "initFunction": "begin",
          "metricsFunction": "metrics"
        },
        {
          "assetId": "d7f7b6c4-9fec-4ff5-9d61-c947e9a109dd",
          "name": "3e2fae01-bb57-4815-b81a-c443d4827d81/d7f7b6c4-9fec-4ff5-9d61-c947e9a109dd.md",
          "assetType": "EXTERNAL_FILE",
          "assetRole": "README_FILE",
          "repositoryInfo": {
            "repositoryType": "S3_REPOSITORY",
            "secure": false,
            "host": "minio",
            "port": 9000,
            "region": "default-region"
          },
          "importedRepository": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "fileUrl": "http://minio:9000/modelop/3e2fae01-bb57-4815-b81a-c443d4827d81/d7f7b6c4-9fec-4ff5-9d61-c947e9a109dd.md",
          "filename": "README.md",
          "fileFormat": "UNKNOWN",
          "fileSize": 304
        },
        {
          "assetId": "f9b72762-8f6f-4ff5-b4b3-36f403f81c1d",
          "assetType": "FILE",
          "assetRole": "MODEL_SCHEMA",
          "repositoryInfo": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "importedRepository": {
            "classicRepository": false,
            "repositoryType": "GIT_REPO",
            "repositoryDirectory": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81",
            "repositoryRemote": "https://github.com/merhi-odg/german_credit_data_drift_detector.git",
            "repositoryBranch": "master",
            "lastCommitId": "78d0531cc82cb725d2f3f1dc601c433b18be2e12"
          },
          "filename": "df_sample_scored_input_schema.avsc",
          "fileFormat": "UNKNOWN",
          "localFile": "/tmp/model-manage-repos/master/3e2fae01-bb57-4815-b81a-c443d4827d81/df_sample_scored_input_schema.avsc",
          "fileSize": 6017,
          "fileContentString": [
            {
              "name": "id",
              "type": "int",
              "dataClass": "numerical",
              "role": "non-predictor",
              "protectedClass": false,
              "driftCandidate": false,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "duration_months",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "credit_amount",
              "type": "float",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "installment_rate",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "present_residence_since",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "age_years",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "number_existing_credits",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "checking_status",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "credit_history",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "purpose",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "savings_account",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "present_employment_since",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "debtors_guarantors",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "property",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "installment_plans",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "housing",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "job",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "number_people_liable",
              "type": "int",
              "dataClass": "numerical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "telephone",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "foreign_worker",
              "type": "boolean",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": false
            },
            {
              "name": "gender",
              "type": "string",
              "dataClass": "categorical",
              "role": "predictor",
              "protectedClass": true,
              "driftCandidate": false,
              "specialValues": [],
              "scoringOptional": true
            },
            {
              "name": "label_value",
              "type": "int",
              "dataClass": "numerical",
              "role": "label",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": true
            },
            {
              "name": "score",
              "type": "int",
              "dataClass": "numerical",
              "role": "score",
              "protectedClass": false,
              "driftCandidate": true,
              "specialValues": [],
              "scoringOptional": true
            }
          ],
          "fileContent": "WwogICAgewogICAgICAgICJuYW1lIjogImlkIiwKICAgICAgICAidHlwZSI6ICJpbnQiLAogICAgICAgICJkYXRhQ2xhc3MiOiAibnVtZXJpY2FsIiwKICAgICAgICAicm9sZSI6ICJub24tcHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiBmYWxzZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJkdXJhdGlvbl9tb250aHMiLAogICAgICAgICJ0eXBlIjogImludCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJjcmVkaXRfYW1vdW50IiwKICAgICAgICAidHlwZSI6ICJmbG9hdCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJpbnN0YWxsbWVudF9yYXRlIiwKICAgICAgICAidHlwZSI6ICJpbnQiLAogICAgICAgICJkYXRhQ2xhc3MiOiAibnVtZXJpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAicHJlc2VudF9yZXNpZGVuY2Vfc2luY2UiLAogICAgICAgICJ0eXBlIjogImludCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJhZ2VfeWVhcnMiLAogICAgICAgICJ0eXBlIjogImludCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJudW1iZXJfZXhpc3RpbmdfY3JlZGl0cyIsCiAgICAgICAgInR5cGUiOiAiaW50IiwKICAgICAgICAiZGF0YUNsYXNzIjogIm51bWVyaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IGZhbHNlCiAgICB9LAogICAgewogICAgICAgICJuYW1lIjogImNoZWNraW5nX3N0YXR1cyIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAiZGF0YUNsYXNzIjogImNhdGVnb3JpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAiY3JlZGl0X2hpc3RvcnkiLAogICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJjYXRlZ29yaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IGZhbHNlCiAgICB9LAogICAgewogICAgICAgICJuYW1lIjogInB1cnBvc2UiLAogICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJjYXRlZ29yaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IGZhbHNlCiAgICB9LAogICAgewogICAgICAgICJuYW1lIjogInNhdmluZ3NfYWNjb3VudCIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAiZGF0YUNsYXNzIjogImNhdGVnb3JpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAicHJlc2VudF9lbXBsb3ltZW50X3NpbmNlIiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJkYXRhQ2xhc3MiOiAiY2F0ZWdvcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJkZWJ0b3JzX2d1YXJhbnRvcnMiLAogICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJjYXRlZ29yaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IGZhbHNlCiAgICB9LAogICAgewogICAgICAgICJuYW1lIjogInByb3BlcnR5IiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJkYXRhQ2xhc3MiOiAiY2F0ZWdvcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJpbnN0YWxsbWVudF9wbGFucyIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAiZGF0YUNsYXNzIjogImNhdGVnb3JpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAiaG91c2luZyIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAiZGF0YUNsYXNzIjogImNhdGVnb3JpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAiam9iIiwKICAgICAgICAidHlwZSI6ICJzdHJpbmciLAogICAgICAgICJkYXRhQ2xhc3MiOiAiY2F0ZWdvcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJudW1iZXJfcGVvcGxlX2xpYWJsZSIsCiAgICAgICAgInR5cGUiOiAiaW50IiwKICAgICAgICAiZGF0YUNsYXNzIjogIm51bWVyaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IGZhbHNlCiAgICB9LAogICAgewogICAgICAgICJuYW1lIjogInRlbGVwaG9uZSIsCiAgICAgICAgInR5cGUiOiAic3RyaW5nIiwKICAgICAgICAiZGF0YUNsYXNzIjogImNhdGVnb3JpY2FsIiwKICAgICAgICAicm9sZSI6ICJwcmVkaWN0b3IiLAogICAgICAgICJwcm90ZWN0ZWRDbGFzcyI6IGZhbHNlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IHRydWUsCiAgICAgICAgInNwZWNpYWxWYWx1ZXMiOiBbXSwKICAgICAgICAic2NvcmluZ09wdGlvbmFsIjogZmFsc2UKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAiZm9yZWlnbl93b3JrZXIiLAogICAgICAgICJ0eXBlIjogImJvb2xlYW4iLAogICAgICAgICJkYXRhQ2xhc3MiOiAiY2F0ZWdvcmljYWwiLAogICAgICAgICJyb2xlIjogInByZWRpY3RvciIsCiAgICAgICAgInByb3RlY3RlZENsYXNzIjogZmFsc2UsCiAgICAgICAgImRyaWZ0Q2FuZGlkYXRlIjogdHJ1ZSwKICAgICAgICAic3BlY2lhbFZhbHVlcyI6IFtdLAogICAgICAgICJzY29yaW5nT3B0aW9uYWwiOiBmYWxzZQogICAgfSwKICAgIHsKICAgICAgICAibmFtZSI6ICJnZW5kZXIiLAogICAgICAgICJ0eXBlIjogInN0cmluZyIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJjYXRlZ29yaWNhbCIsCiAgICAgICAgInJvbGUiOiAicHJlZGljdG9yIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiB0cnVlLAogICAgICAgICJkcmlmdENhbmRpZGF0ZSI6IGZhbHNlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IHRydWUKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAibGFiZWxfdmFsdWUiLAogICAgICAgICJ0eXBlIjogImludCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogImxhYmVsIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IHRydWUKICAgIH0sCiAgICB7CiAgICAgICAgIm5hbWUiOiAic2NvcmUiLAogICAgICAgICJ0eXBlIjogImludCIsCiAgICAgICAgImRhdGFDbGFzcyI6ICJudW1lcmljYWwiLAogICAgICAgICJyb2xlIjogInNjb3JlIiwKICAgICAgICAicHJvdGVjdGVkQ2xhc3MiOiBmYWxzZSwKICAgICAgICAiZHJpZnRDYW5kaWRhdGUiOiB0cnVlLAogICAgICAgICJzcGVjaWFsVmFsdWVzIjogW10sCiAgICAgICAgInNjb3JpbmdPcHRpb25hbCI6IHRydWUKICAgIH0KXQo="
        },
        {
          "assetId": "bc74635b-5084-4dd8-a128-0ea62c8ce1b0",
          "name": "3e2fae01-bb57-4815-b81a-c443d4827d81/bc74635b-5084-4dd8-a128-0ea62c8ce1b0.dmn",
          "assetType": "EXTERNAL_FILE",
          "assetRole": "TEST_RESULT_COMPARATOR",
          "repositoryInfo": {
            "repositoryType": "S3_REPOSITORY",
            "secure": false,
            "host": "minio",
            "port": 9000,
            "region": "default-region"
          },
          "fileUrl": "http://minio:9000/modelop/3e2fae01-bb57-4815-b81a-c443d4827d81/bc74635b-5084-4dd8-a128-0ea62c8ce1b0.dmn",
          "filename": "enron_dmn.dmn",
          "fileFormat": "UNKNOWN",
          "fileSize": 2230
        },
        {
          "assetId": "e45d070b-23c8-4ee7-b5bc-14dfe11309b6",
          "name": "3e2fae01-bb57-4815-b81a-c443d4827d81/e45d070b-23c8-4ee7-b5bc-14dfe11309b6.json",
          "assetType": "EXTERNAL_FILE",
          "assetRole": "COMPARATOR_DATA",
          "repositoryInfo": {
            "repositoryType": "S3_REPOSITORY",
            "secure": false,
            "host": "minio",
            "port": 9000,
            "region": "default-region"
          },
          "fileUrl": "http://minio:9000/modelop/3e2fae01-bb57-4815-b81a-c443d4827d81/e45d070b-23c8-4ee7-b5bc-14dfe11309b6.json",
          "filename": "df_sample.json",
          "fileFormat": "JSON",
          "fileSize": 92486
        }
      ],
      "associatedModels": []
    },
    "metaData": {
      "custom": {},
      "tags": [],
      "name": "german_credit_data_drift_detector-20210303_1133"
    },
    "associatedModels": [],
    "modelDocuments": [],
    "targetRuntimes": []
  },
  "targetEngine": {
    "engineType": "SPARK_RUNTIME",
    "name": "spark-runtime-1",
    "inputEndpoints": [],
    "outputEndpoints": []
  }
}